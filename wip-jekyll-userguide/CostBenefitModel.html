---
layout: default-userguide
---
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Cost Benefit Model</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html,2 --> 
<meta name="src" content="index.tex"> 
<meta name="date" content="2015-06-13 12:58:00"> 
<link rel="stylesheet" type="text/css" href="index.css"> 
</head><body 
>
<!--l. 2--><div class="crosslinks"><p class="noindent">[<a 
href="LifeCycleOfACompiledMethod.html" >next</a>] [<a 
href="OptTestHarness.html" >prev</a>] [<a 
href="OptTestHarness.html#tailOptTestHarness.html" >prev-tail</a>] [<a 
href="#tailCostBenefitModel.html">tail</a>] [<a 
href="index.html#CostBenefitModel.html" >up</a>] </p></div>
<h3 class="sectionHead"><span class="titlemark">4   </span> <a 
 id="x5-50004"></a>Cost Benefit Model</h3>
<!--l. 3--><p class="noindent" >The Jikes RVM Adaptive Optimization System attempts to evaluate the break-even
point for each action using an online competitive algorithm. It relies on an analytic
model to estimate the costs and benefits of each selective recompilation
action, and evaluates the best actions according to the model predictions
online.
<!--l. 5--><p class="noindent" >A key advantage of this approach is that it allows a designer to extend the simple
&#8221;break-even&#8221; cost-benefit model to account for more sophisticated adaptive policies,
such as selective compilation with multiple optimization levels, on-stack-replacement,
and long-running analyses.
<!--l. 7--><p class="noindent" >In general, each potential action will incur some cost and may confer some benefit.
For example, recompiling a method will certainly consume some CPU cycles, but
could speed up the program execution by generating better code. In this
discussion we focus on costs and benefits defined in terms of time (CPU
cycles). However, in general, the controller could consider other measures of
cost and benefit, such as memory footprint, garbage allocated, or locality
disrupted.
<!--l. 9--><p class="noindent" >The controller will take some action when it estimates the benefit to exceed the cost.
More precisely, when the controller wakes at time <span 
class="cmmi-10">t</span>, it considers a set of <span 
class="cmmi-10">n </span>available
actions, the set <span 
class="cmmi-10">A </span>= <span 
class="cmsy-10">{</span><span 
class="cmmi-10">A</span><sub><span 
class="cmr-7">1</span></sub><span 
class="cmmi-10">,A</span><sub><span 
class="cmr-7">2</span></sub><span 
class="cmmi-10">,...,A</span><sub><span 
class="cmmi-7">n</span></sub><span 
class="cmsy-10">}</span>. For any subset <span 
class="cmmi-10">S </span>in <span 
class="cmmi-10">P</span>(<span 
class="cmmi-10">A</span>), the controller can
estimate the cost <span 
class="cmmi-10">C</span>(<span 
class="cmmi-10">S</span>) and benefit <span 
class="cmmi-10">B</span>(<span 
class="cmmi-10">S</span>) of performing all actions <span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">i</span></sub> in <span 
class="cmmi-10">S</span>. The
controller will attempt to choose the subset <span 
class="cmmi-10">S </span>that maximizes <span 
class="cmmi-10">B</span>(<span 
class="cmmi-10">S</span>) <span 
class="cmsy-10">- </span><span 
class="cmmi-10">C</span>(<span 
class="cmmi-10">S</span>).
Obviously <span 
class="cmmi-10">S </span>= <span 
class="cmsy-10">{} </span>has <span 
class="cmmi-10">B</span>(<span 
class="cmmi-10">S</span>) = <span 
class="cmmi-10">C</span>(<span 
class="cmmi-10">S</span>) = 0; the controller takes no action if it cannot
find a profitable course.
<!--l. 11--><p class="noindent" >In practice, the precise cost and benefit of each action cannot be known; so, the
controller must rely on estimates to make decisions.
<!--l. 13--><p class="noindent" >The basic model the controller uses to decide which method to recompile, at which
optimization level, and at what time is as follows.
<!--l. 15--><p class="noindent" >Suppose that when the controller wakes at time <span 
class="cmmi-10">t</span>, and each method <span 
class="cmmi-10">m </span>is currently
optimized at optimization level <span 
class="cmmi-10">m</span><sub><span 
class="cmmi-7">i</span></sub><span 
class="cmmi-10">,</span>0 <span 
class="cmsy-10">&#x2264; </span><span 
class="cmmi-10">i </span><span 
class="cmsy-10">&#x2264; </span><span 
class="cmmi-10">k</span>. Let <span 
class="cmmi-10">M </span>be the set of loaded methods in
the program. Let <span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">jm</span></sub> be the action &#8221;recompile method m at optimization level <span 
class="cmmi-10">j</span>, or
do nothing if <span 
class="cmmi-10">j </span>= <span 
class="cmmi-10">i</span>.&#8221;
<!--l. 17--><p class="noindent" >The controller must choose an action for each <span 
class="cmmi-10">m </span>in <span 
class="cmmi-10">M</span>. The set of available actions is
<span 
class="cmmi-10">Actions </span>= <span 
class="cmsy-10">{</span><span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">jm</span></sub><span 
class="cmsy-10">|</span>0 <span 
class="cmsy-10">&#x2264; </span><span 
class="cmmi-10">j </span><span 
class="cmsy-10">&#x2264; </span><span 
class="cmmi-10">k,m </span><span 
class="cmsy-10">&#x2208; </span><span 
class="cmmi-10">M</span><span 
class="cmsy-10">}</span>.
<!--l. 19--><p class="noindent" >Each action has an estimated cost and benefit: <span 
class="cmmi-10">C</span>(<span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">jm</span></sub>), the cost of taking action
<span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">jm</span></sub>, for 0 <span 
class="cmsy-10">&#x2264; </span><span 
class="cmmi-10">j </span><span 
class="cmsy-10">&#x2264; </span><span 
class="cmmi-10">k </span>and <span 
class="cmmi-10">T</span>(<span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">jm</span></sub>), the expected time the program will spend executing
method <span 
class="cmmi-10">m </span>in the future, if the controller takes action <span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">jm</span></sub>.
<!--l. 21--><p class="noindent" >For <span 
class="cmmi-10">S </span>in <span 
class="cmmi-10">Actions</span>, define <span 
class="cmmi-10">C</span>(<span 
class="cmmi-10">S</span>) = <span 
class="cmex-10">&#x2211;</span>
  <sub><span 
class="cmmi-7">s</span><span 
class="cmsy-7">&#x2208;</span><span 
class="cmmi-7">S</span></sub><span 
class="cmmi-10">C</span>(<span 
class="cmmi-10">s</span>). Given <span 
class="cmmi-10">S</span>, for each <span 
class="cmmi-10">m </span>in <span 
class="cmmi-10">M</span>,
define <span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">min</span><sub><span 
class="cmmi-5">m</span></sub></sub> to be the action <span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">jm</span></sub> in <span 
class="cmmi-10">S </span>that minimizes <span 
class="cmmi-10">T</span>(<span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">jm</span></sub>). Then define
<span 
class="cmmi-10">T</span>(<span 
class="cmmi-10">S</span>) = <span 
class="cmex-10">&#x2211;</span>
  <sub><span 
class="cmmi-7">m</span><span 
class="cmsy-7">&#x2208;</span><span 
class="cmmi-7">M</span></sub><span 
class="cmmi-10">T</span>(<span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">min</span><sub><span 
class="cmmi-5">m</span></sub></sub>).
<!--l. 23--><p class="noindent" >Using these estimated values, the controller chooses the set <span 
class="cmmi-10">S </span>that minimizes
<span 
class="cmmi-10">C</span>(<span 
class="cmmi-10">S</span>) + <span 
class="cmmi-10">T</span>(<span 
class="cmmi-10">S</span>). Intuitively, for each method <span 
class="cmmi-10">m</span>, the controller chooses the recompilation
level <span 
class="cmmi-10">j </span>that minimizes the expected future compilation time and running time of
                                                                  

                                                                  
<span 
class="cmmi-10">m</span>.
<!--l. 25--><p class="noindent" >It remains to define the functions <span 
class="cmmi-10">C </span>and <span 
class="cmmi-10">T </span>for each recompilation action. The basic
model models the cost <span 
class="cmmi-10">C </span>of compiling a method <span 
class="cmmi-10">m </span>at level <span 
class="cmmi-10">j </span>as a linear function of
the size of <span 
class="cmmi-10">m</span>. The linear function is determined by an offline experiment to fit
constants to the model.
<!--l. 27--><p class="noindent" >The basic model estimates that the speedup for any optimization level <span 
class="cmmi-10">j </span>is constant.
The implementation determines the constant speedup factor for each optimization
level offline, and uses the speedup to compute <span 
class="cmmi-10">T </span>for each method and optimization
level.
<!--l. 29--><p class="noindent" >We assume that if the program has run for time <span 
class="cmmi-10">t</span>, then the program will run for
another <span 
class="cmmi-10">t </span>units, and then terminate. We further assume program behavior in the
future will resemble program behavior in the past. Therefore, for each method we
estimate that if no optimization action is performed <span 
class="cmmi-10">T</span>(<span 
class="cmmi-10">A</span><sub><span 
class="cmmi-7">jm</span></sub>) is equal to the time
spent executing method <span 
class="cmmi-10">m </span>so far.
<!--l. 31--><p class="noindent" >Let <span 
class="cmmi-10">M </span>= (<span 
class="cmmi-10">m</span><sub><span 
class="cmr-7">1</span></sub><span 
class="cmmi-10">,...,m</span><sub><span 
class="cmmi-7">k</span></sub>) be the <span 
class="cmmi-10">k </span>compiled methods. When the controller wakes at time
<span 
class="cmmi-10">t</span>, each compiled method <span 
class="cmmi-10">m </span>has been sampled <span 
class="cmex-10">&#x2211;</span>
  <span 
class="cmmi-10">m </span>times. Let <span 
class="cmmi-10">&#x03B4; </span>be the sampling
interval, measured in seconds. The controller estimates that method <span 
class="cmmi-10">m </span>has executed
<span 
class="cmmi-10">&#x03B4;</span> <span 
class="cmex-10">&#x2211;</span>
  <span 
class="cmmi-10">m </span>seconds so far, and will execute for another <span 
class="cmmi-10">&#x03B4;</span> <span 
class="cmex-10">&#x2211;</span>
  <span 
class="cmmi-10">m </span>seconds in the
future.
<!--l. 33--><p class="noindent" >When driving recompilation based on sampling, the controller can limit its attention
to the set of methods that were sampled in the previous sampling interval. This
optimization does not lose precision; if the number of samples associated with a
method has not changed, then the controller&#8217;s estimate of the method&#8217;s future
execution time will not change. This implies that if the controller were to consider a
method that does not appear in the previous sampling interval, the controller would
make exactly the same decision it did the last time it considered the method. This
optimization, limiting the number of methods the controller must examine in each
sampling interval, greatly reduces the amount of work performed by the
controller.
<!--l. 36--><p class="noindent" >Suppose the controller recompiles method m from optimization level <span 
class="cmmi-10">i </span>to
optimization level <span 
class="cmmi-10">j </span>after having seen <span 
class="cmex-10">&#x2211;</span>
  <span 
class="cmmi-10">m </span>samples. Let <span 
class="cmmi-10">S</span><sub><span 
class="cmmi-7">i</span></sub> and <span 
class="cmmi-10">S</span><sub><span 
class="cmmi-7">j</span></sub>be the speedup
ratios for optimization levels <span 
class="cmmi-10">i </span>and <span 
class="cmmi-10">j</span>, respectively. After optimizing at level <span 
class="cmmi-10">j</span>, we
adjust the sample data to represent the system state as if it had executed
method <span 
class="cmmi-10">m </span>at optimization level <span 
class="cmmi-10">j </span>since program startup. So, we set the new
number of samples for <span 
class="cmmi-10">m </span>to be <span 
class="cmex-10">&#x2211;</span>
  <span 
class="cmmi-10">m </span><span 
class="cmsy-10">&#x22C5; </span>(<span 
class="cmmi-10">S</span><sub><span 
class="cmmi-7">i</span></sub><span 
class="cmmi-10">&#x2215;S</span><sub><span 
class="cmmi-7">j</span></sub>). Thus to compute the time spent
in <span 
class="cmmi-10">m</span>, we need know only one number, the &#8221;effective&#8221; number of samples.
                                                                  

                                                                  
<!--l. 2--><div class="crosslinks"><p class="noindent">[<a 
href="LifeCycleOfACompiledMethod.html" >next</a>] [<a 
href="OptTestHarness.html" >prev</a>] [<a 
href="OptTestHarness.html#tailOptTestHarness.html" >prev-tail</a>] [<a 
href="CostBenefitModel.html" >front</a>] [<a 
href="index.html#CostBenefitModel.html" >up</a>] </p></div>
<!--l. 2--><p class="noindent" ><a 
 id="tailCostBenefitModel.html"></a> 
</body></html> 
