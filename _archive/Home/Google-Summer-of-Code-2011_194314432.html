<!DOCTYPE html>
<html>
    <head>
        <title>RVM : Google Summer of Code 2011</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">RVM</a></span>
                            </li>
                                                    <li>
                                <span><a href="Home.html">Home</a></span>
                            </li>
                                                    <li>
                                <span><a href="Google-Summer-of-Code_74383603.html">Google Summer of Code</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            RVM : Google Summer of Code 2011
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
    
            Created by <span class='author'> Richard Jones</span>, last modified by <span class='editor'> David Grove</span> on Sep 27, 2012
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <h2 id="GoogleSummerofCode2011-Outcomes">Outcomes</h2><p>This year we had four Summer of Code projects. We are very grateful to Google for their support and are pleased that all four students successfully passed. As part of the GSoC, Google also provided Jikes RVM with 4 x $500 which we will use to support the regression testing kit at ANU. Below are short summaries of the outcomes of the four projects. The source code for all these project can be found at <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011</a>.</p><h3 id="GoogleSummerofCode2011-1)ToolsfordebuggingtheJikesRVMruntime">1) <strong>Tools for debugging the Jikes RVM runtime</strong></h3><p>My project sought to deliver tools for debugging the Jikes RVM runtime. We decided that implementing the JVM Tools Interface (JVMTI) would be a good way of doing this, allowing both application-level debugging (through a JDWP agent) and low-level access to VM internals. The end result of the project was a partially working implementaion of JVMTI, with most of the infrastructure in place to complete an implementation.</p><p>JVMTI allows us to write a native (C/C++) agent to interact with the VM at runtime, responding to events and modifying VM state. This allows us to do things at runtime such as redefine bytecode for classes, hook method entry and exit and field access/modification, track heap allocations, etc - essentially, instrument the VM in fairly arbitrary ways. It can also allow us to look at lower level VM areas, inspecting the stack and in some instances being able to access VM state.</p><p>The major stumbling blocks related to threading and monitors and the JVMTI implementations thereof. This, combined with the sheer size of the specification (even after reducing it to simpler test cases) mean only a partially operating implementation is available. I intend to revisit these later this month when coursework dies down again, with the goal of getting it to a state where it can be committed to the head. This does not necessarily mean it will be a fully functional and compliant implementation of the specification, but the goal is to have most of Harmony's implementation of a JDWP agent using JVMTI operational. This will allow some form of interactive debugging at the application level (using e.g. the Eclipse debugger), but the parts of JVMTI implemented to make this happen will also allow other, lower level tasks to be completed. For now, my work is on a branch in our soc2011 repository at <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011</a>, together with a readme describing the future directions further.</p><p>The implementation itself, in the org.jikesrvm.runtime.jvmti package, consists of:</p><ul><li>Infrastructure to allow arbitrary native agents (as shared libraries, the same as JNI) to be loaded and managed (JVMTI, JVMTIAgent)</li><li>Plumbing for the VM to send events to agents through a small JNI trampoline (JVMTIEventTrampoline)</li><li>Three events are actually implemented - VMStart (during boot), VMInit (immediately before application main), ThreadStart. Others are mostly a copy/paste job, then inserting the call in the appropriate place</li><li>Missing: proper handling of events a normal JVM would fire that we initialise instead in the boot image</li><li>Roughly 65 of the 155 JVMTI functions implemented, including most relating to methods, classes, fields (JVMTIFunctions)</li><li>Key parts missing: breakpoints, set/get local vars, early returns, stackframe-related stuff</li><li>Ability for agents to spawn threads running arbitrary native code (not fully functional)</li></ul><p>Also included, in the test-agents directory, are some simple JVMTI agents used to test various parts of the implementation for functionality.</p><p>I've greatly appreciated the opportunity to work on Jikes RVM, especially because I came to Summer of Code having already used it for my own research work. In particular, I'm grateful to Richard for managing our involvement in the program, and to Steve, Daniel and Dave for their advice and willingness to answer my silly questions.</p><p>James Bornholt</p><h3 id="GoogleSummerofCode2011-2)AnEfficientMark&amp;SweepConcurrentSnapshot-BasedAndOnTheFlySliding-ViewsbasedGarbageCollectorsForJikesRVM">2) <strong>An Efficient Mark &amp; Sweep Concurrent Snapshot-Based And On The Fly Sliding-Views based Garbage Collectors For Jikes RVM</strong></h3><p>The project's code is in branch RVM-923-Snapshot. The project is an implementation of a concurrent garbage collector, based on the Snapshot algorithm for garbage collection, and it is intended as a first step towards the on-the-fly Sliding-views based algorithm. </p><p>Both algorithms are described in the paper &quot;An on-the-fly mark &amp; sweep garbage collector based on sliding-views&quot; by Aztachi, Levanoni, Paz &amp; Petrank, OOPSLA 2003. The idea behind the implemented (snapshot) algorithm is to take a 'snapshot' of the heap, and trace objects within it. During the mark phase, if an attempt is made to modify an object before it has been traced, we first take a replica of its pointers and save them in an auxiliary buffer (this is done only once per object).  The algorithm uses two mark bits for every object, enabling four possible colors. This is essential to support the color-toggle mechanism, that swaps the black and white colors before every collection cycle. </p><p>The new collector is implemented in the org.mmtk.concurrent.marksweep folder, but naturally many other classes were added and or edited in the MMtk outside this folder. Note that this folder also exists in the trunk, but it contains a different algorithm. The algorithm in the trunk, when attempting to modify a pointer, first traces through the target object (the object that a pointer towards it is going to be overwritten), instead of replicating the source object (the object that contains the pointer going go be overwritten), like the &quot;new&quot; snapshot algorithm. This &quot;older&quot; implementation is technically simpler, but has several drawbacks, mainly in locality (which leads to a less efficient write-barrier) and that statistically the barrier has to scan more objects, according to most benchmarks (which is again, less efficient). Also this &quot;older&quot; algorithm doesn't fit as well as a basis for the on-the-fly sliding-views algorithm. </p><p>The new collector was not yet thoroughly tested, and is not yet ready for practical usage. It was tested so far only in the MMTk.harness environment. The algorithm successfully passes all the  MMTk.harness tests. There is, however, a race condition that occurs in about 1 in 1000 GC cycles, that results in a deadlock. This is currently the only known bug, but other bugs are likely to exists as well, due to insufficient testing.</p><p>The implemented collector currently works with concurrent tracing, but the sweeping is still done in the &quot;Stop The World&quot; mode. This should be modified, to support full concurrency. Some efficiency issues should also be addressed, as the implementation has not been optimized yet. Most notably, a better mechanism should be applied to decide when to reclaim an entire block of memory. The regular (not concurrent) mark-sweep algorithm, does this by using a mark bit for each block. This solution currently can't be used simultaneously with the 'preserveFreeLists' option, since the BlockAllocator uses the same Word field both for the mark of the block and for the free-list head. Currently, the concurrent mark-sweep algorithm determines if a block can be reclaimed by checking every one of its cell, but this is clearly not efficient. The best solution is probably to have the BlockAllocator use the least significant bit of the Word only as a mark bit for the block, and accordingly change its code a little to allow it to simultaneously support both the preserveFreeList and mark bit for blocks.</p><p>Shahar Timnat</p><h3 id="GoogleSummerofCode2011-3)Newyounggenerationarchitectureforthegenerationalgarbagecollector">3) New young generation architecture for the generational garbage collector</h3><p>The project is accessible via Mercurial at <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011</a><a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011" class="external-link" rel="nofollow"> under the branch RVM-924-GARY46.</a></p><p>The goal of the project was to compare different young generation models in one virtual machine. The young generation organisations compared were Steps (e.g. as used by the GHC Haskell system), Eden and Survivor spaces (as used by HotSpotO and the default “en masse” promotion model (e.g. only one space in the nursery).</p><p>In order to build new young generation models, the young generation has been redesigned.  The objective is to allow the use of new nursery without duplicating the old generations for each model. Garbage collectors in JikesRVM are built using hierarchical dependencies which simplifies the creation of new collectors but increase the complexity when tweaking with the middle components. The project modified the young generation to use delegate classes to manage the nursery’s spaces. This is similar to the use of delegates for the tracing (e.g. MatureTraceLocal, NurseryTraceLocal). Each class of the young generation uses a delegate because they are all affected by modifications to the nursery. This has a cost and the default “en masse” promotion model runs 20% slower than the original design.  Results from the Steps and Eden + Survivor models, show that they are 20% slower than de “en masse” promotion, therefore 40% slower than the original design. In the current implementation, the increase of space usage also triggers an error with small amount of memory. This error is also present in the original design but is triggered more often with the new young generations. The OutOfMemoryException is not always thrown, Exceptions from the Main Thread or the benchmark running can be expected. This is not a normal behavior. Hopefully, the work on the young generation will help prevent this bug from happening. The project is at a stage where it needs to be greatly optimized, 20 to 40 % speed difference with the original design is excessive. For example, remsets might be replaced by card tables and it might be possible for the delegates to take more advantage of the optimizing compiler.</p><p>Gary Rampaud</p><h3 id="GoogleSummerofCode2011-4)Multi-MethodCompilation">4) Multi-Method Compilation</h3><p>Multi-Method is a technique where one or more methods are put on a thread to be compiled in parallel. The granularity is coarse when compared to single method. Currently Pre Compile [1], Hot Method Recompilation [2], and Boot [3] have been modified to utilize Multi-Method . The parallel Multi-Method is the most stable of all three and the parallel Boot and Pre-Compile need to be improved.</p><h4 id="GoogleSummerofCode2011-WhyMulti-ThreadPreCompile[1,15],HotMethodRecompilation[2,4],andBoot[3,14]?">Why Multi-Thread PreCompile [1,15], Hot Method Recompilation [2,4], and Boot [3,14] ?</h4><p>Hot Method Recompilation [2] – The original design of recompilation of the hot methods in the current Jikes RVM head made it very easy to multi-thread due to the fact that recompilation of hot methods was already controlled by one daemon thread running in the background constantly waiting for hot methods [6] and recompiling them in the background. All that needed to be done to utilize parallel processing was just spawn more Compilation Threads [5] and add a command line argument to specify the number of threads the user desires. It is important to remember that multi-threaded recompilation of hot methods will only be effective when the user's software or benchmark produces a certain amount of hot methods to be recompiled, otherwise there will be no speedup due to thread overhead or even worse a slow down. One can tune Jikes RVM recompilation heuristics in the following source code files CompilerDNA.java [16,17],<a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">AnalyticModel.java</a> [6,18], to increase the number of hot methods in the recompilation queue.</p><p>Command to run with N threads: ./rvm -X:aos:num_threads=2 -cp scimark2lib.jar jnt.scimark2.commandline (eg with scimark2lib.jar)</p><p>Pre Compile [1] – Pre Compile's core method that controls compilation is embarrassingly parallel because it uses a For loop to iterate over each Method. Currently due to time constraints of Google Summer the multi-threaded PreCompile method is in an non-optimized version 0 state and is currently seeing overhead but the overhead is minimal because it is causing neither a speed up nor a slow down in other words the running time is the same. However, that can be easily fixed by sending groups of data onto a thread at once preferably 1/2 methods for thread one and 1/2 methods for thread two on a two thread system which is an optimization that was used to help improve multi-threade Single-Method [8,9,10,11,12,13].</p><p>Command to run and generate advice file: ./rvm -X:aos:enable_advice_generation=true -cp dacapo-2006-10-MR2.jar Harness xalan</p><p>Command to run and precompile advice file with N threads: ./rvm -X:aos:enable_precompile=true -X:aos:pre_compile_threads=2 -X:aos:cafi=aosadvice.ca -cp dacapo-2006-10-MR2.jar Harness xalan</p><p>Boot [3] – The main advantage to multi-threading the boot [3] source file is because in the Jikes RVM the Boot code compiles around 100 methods every time. The beauty in this multi-threaded optimization is the speedup achieved by this optimization is independent of the benchmark or program the user is running. Unfortunately this optimization is still in a pre version 0 phase, however I hope to polish it up in the near future as continued post GSOC work. The ordering of the class initialization becomes non-deterministic due to arbitrary thread inter-leavings. This causes problems when Class A is required before Class B and Class A and Class B are on two different threads.</p><h4 id="GoogleSummerofCode2011-Single-MethodCompilation[7]">Single-Method Compilation [7]</h4><p>Single-Method parallel compilation is a technique where each method is optimized using multi-threaded compiler optimization. Occasionally when the compiler needs to optimize and compile large methods (around 14,000 Instructions on Core i5) it is better to dedicate all the available threads to one method. For this project we focused on flow insensitive optimization's [7] in the jikes rvm as a baseline implementation. In our experiments we multi-threaded insruction level and register level optimizations and the next logical step for future work is to experiment with block level optimization's and flow sensitive optimization's.</p><h4 id="GoogleSummerofCode2011-CurrentOptimizationsthatareMutli-threadedforSingle-Method">Current Optimizations that are Mutli-threaded for Single-Method</h4><ul><li>Sort Commutative Register Uses[8,12]</li><li>Copy Propagation[9]</li><li>Array Propagation [10]</li><li>Type Propagation [11]</li><li>RecomputeSSA [13]</li></ul><h4 id="GoogleSummerofCode2011-Single-Method[7-13]FutureWork">Single-Method [7-13] Future Work</h4><ul><li>Determine if any form of compiler optimization in the jikes rvm can benefit greatly from Single-Method</li><li>Possibly use the power of the GPU or the Cell processor to accelerate Single Method</li></ul><h4 id="GoogleSummerofCode2011-Multi-Method[1,2,3]FutureWork">Multi-Method [1,2,3] Future Work</h4><ul><li>Tune the compiler DNA to allow for more efficient multi-threaded recompilation of hot methods</li><li>Evaluate if any other locations in the Source Code can benefit from multi-method compilation</li></ul><h4 id="GoogleSummerofCode2011-References">References</h4><p>[1] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/e3397f4b5006" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/e3397f4b5006</a><br /> [2] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/fed20f02f806" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/fed20f02f806</a><br /> [3] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/1c6019198603" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/1c6019198603</a><br /> [4] <a href="http://parallelcompiler.blogspot.com/2011/07/new-design-mutlimethod.html" class="external-link" rel="nofollow">http://parallelcompiler.blogspot.com/2011/07/new-design-mutlimethod.html</a><br /> [5] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/file/fed20f02f806/rvm/src/org/jikesrvm/adaptive/recompilation/CompilationThread.java" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/file/fed20f02f806/rvm/src/org/jikesrvm/adaptive/recompilation/CompilationThread.java</a><br /> [6] <a href="ftp://ftp.cs.man.ac.uk/pub/apt/theses/ChristosKotselidis_MSc.pdf" class="external-link" rel="nofollow">ftp://ftp.cs.man.ac.uk/pub/apt/theses/ChristosKotselidis_MSc.pdf</a><br /> [7] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/file/b3a96880313a/rvm/src/org/jikesrvm/compilers/opt/Simple.java" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/file/b3a96880313a/rvm/src/org/jikesrvm/compilers/opt/Simple.java</a><br /> [8] <a href="http://parallelcompiler.blogspot.com/2011/07/version-1-sortcommutative-registeruses.html" class="external-link" rel="nofollow">http://parallelcompiler.blogspot.com/2011/07/version-1-sortcommutative-registeruses.html</a><br /> [9] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/a5e56291dbf0" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/a5e56291dbf0</a><br /> [10] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/362d399161e5" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/362d399161e5</a><br /> [11] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/84029a70dce4" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/84029a70dce4</a><br /> [12] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/066d79055dbc" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/066d79055dbc</a><br /> [13] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd</a><br /> [14] <a href="http://parallelcompiler.blogspot.com/2011/08/parallel-boot.html" class="external-link" rel="nofollow">http://parallelcompiler.blogspot.com/2011/08/parallel-boot.html</a><br /> [15] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">http://parallelcompiler.blogspot.com/2011/08/parallel-precompile.html</a><br /> [16] <a href="http://docs.codehaus.org/display/RVM/Compiler+DNA" rel="nofollow">http://docs.codehaus.org/display/RVM/Compiler+DNA</a><br /> [17] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/jikesrvm/file/c6bfce68e447/rvm/src/org/jikesrvm/adaptive/recompilation/CompilerDNA.java\</a><br /> [18] <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/jikesrvm/file/c6bfce68e447/rvm/src/org/jikesrvm/adaptive/controller/AnalyticModel.java</a><br /> <a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd</a></p><p><a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd</a></p><p><a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd</a></p><p><a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd</a></p><p><a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd</a></p><p><a href="http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd" class="external-link" rel="nofollow">http://hg.code.sourceforge.net/p/jikesrvm/soc2011/rev/ab1c9ed8e2dd</a></p><p>Michael Taylor</p><h2 id="GoogleSummerofCode2011-Call">Call</h2><p>The mentoring organization application deadline for the <a href="http://code.google.com/soc/" class="external-link" rel="nofollow">Google Summer of Code 2011</a> is <a href="http://socghop.appspot.com/" class="external-link" rel="nofollow">March 11</a>. We have had some really excellent contributions to <a href="http://jikesrvm.org" class="external-link" rel="nofollow">JikesRVM</a> come out of previous Summers of Code, and we intend to apply again. For this we need a strong set of proposals, so please take the time to look at the ones below and offer some more.</p><p><a href="http://socghop.appspot.com/" class="external-link" rel="nofollow">FAQs etc</a></p><p><a href="http://socghop.appspot.com/document/show/gsoc_program/google/gsoc2011/faqs#timeline" class="external-link" rel="nofollow">Timeline</a></p><p><a href="Google-Summer-of-Code-2011-template_194314434.html">Student application template</a></p><p><a href="Google-Summer-of-Code_74383603.html">Previous years</a></p><h1 id="GoogleSummerofCode2011-Proposalsproposals2011">Proposals<span class="confluence-anchor-link" id="GoogleSummerofCode2011-proposals2011"></span></h1><p>The projects are organised into the major components of Jikes RVM that they effect: Infrastructure, Garbage Collector (MMTk), Compilers and the Runtime System. We also have other projects that relate to Jikes RVM.</p><h2 id="GoogleSummerofCode2011-JikesRVMinfrastructureproposals">Jikes RVM infrastructure proposals</h2><h3 id="GoogleSummerofCode2011-EnableJikesRVMtouseOpenJDKclasslibraries">Enable Jikes RVM to use OpenJDK class libraries</h3><p>We believe the largest limitation in the set of programs that can be run on Jikes RVM is that Jikes RVM primarily relies on the GNU Classpath class libraries. The most viable library plan for Jikes RVM is to switch to using Open JDK libraries. The work in switching is primarily in the VM/library interface and in the &quot;core&quot; classes in java.lang. This project for be of significant value to the research community because it will widen the set of benchmarks that can be used for Jikes RVM research.</p><p>Interested mentors: Daniel Frampton</p><h3 id="GoogleSummerofCode2011-GetthenewDaCapobenchmarks(dacapo-9.12-bach)runningonJikesRVM.">Get the new DaCapo benchmarks (dacapo-9.12-bach) running on Jikes RVM.</h3><p>A number of the new DaCapo benchmarks don't run on Jikes RVM. This project would be to figure out why each failing program is failing and get make fixes to Jikes RVM and/or its class libraries to make the programs work. This would be of significant value to the Jikes RVM research community.</p><p>Interested mentors: Steve Blackburn</p><h2 id="GoogleSummerofCode2011-GarbageCollector(MMTk)proposals">Garbage Collector (MMTk) proposals</h2><h3 id="GoogleSummerofCode2011-ConcurrentGarbageCollectors">Concurrent Garbage Collectors</h3><p>MMTk has a basic concurrent garbage collector and Laurence Hellyer added Sapphire as part of GSoC 2010. However, we would like to have more, for example, Concurrent <a href="http://dx.doi.org/10.1145/1375581.1375586" class="external-link" rel="nofollow">immix</a>, the Doliguez-Leroy-Gonthier algorithm (<a href="ftp://ftp.inria.fr/INRIA/Projects/cristal/Xavier.Leroy/publications/concurrent-gc.ps.gz" class="external-link" rel="nofollow">POPL93</a>, <a href="ftp://ftp.inria.fr/INRIA/Projects/para/doligez/DoligezGonthier94.ps.gz" class="external-link" rel="nofollow">POPL94</a>, <a href="http://dx.doi.org.chain.kent.ac.uk/10.1145/362422.362484" class="external-link" rel="nofollow">ISMM00</a>), Azatchi et al (<a href="http://www.cs.technion.ac.il/%7Eerez/papers.html" class="external-link" rel="nofollow">OOPSLA03</a>), or mostly concurrent (<a href="http://dx.doi.org/10.1145/113445.113459" class="external-link" rel="nofollow">Boehm91</a>, <a href="http://dx.doi.org/10.1145/1108970.1108972" class="external-link" rel="nofollow">Barabash et al 2005</a>).</p><p>Interested mentors: Tony Hosking, Erez Petrank, Daniel Frampton, Eliot Moss, Richard Jones</p><h3 id="GoogleSummerofCode2011-GenerationalCollectorOrganisation">Generational Collector Organisation</h3><p>Currently, the generational collectors in Jikes RVM use en masse promotion, i.e. all surviving objects in the nursery are promoted to the mature generation. Other VMs have adopted more complex generational organisations that require objects to survive more nursery collections before they are promoted. For example, HotSpot divides the young generation into an <em>Eden</em> (where objects are created) and <em>Survivor semispaces</em>. Implementations for functional languages have typically organised generations into <em>steps</em>. This project would implement some of these organisations.</p><p>Interested mentors: Richard Jones, Eliot Moss</p><h3 id="GoogleSummerofCode2011-GarbageCollectionVisualisation">Garbage Collection Visualisation</h3><p>The <a href="http://www.cs.kent.ac.uk/projects/gc/gcspy/" class="external-link" rel="nofollow">GCspy</a> framework has become slightly out-of-date and needs improving [<a href="http://jira.codehaus.org/browse/RVM-388" class="external-link" rel="nofollow">RVM-388</a>].</p><p>Interested mentors: Richard Jones</p><h3 id="GoogleSummerofCode2011-TheCompressorMark-CompactGarbageCollector">The Compressor Mark-Compact Garbage Collector</h3><p>This project would add the <a href="http://doi.acm.org/10.1145/1133255.1134023" class="external-link" rel="nofollow">Compressor</a> Mark-Compact algorithm to MMTK's suite of collectors, starting with a stop-the-world implementation<br /> [<a href="http://jira.codehaus.org/browse/RVM-401" class="external-link" rel="nofollow">RVM-401</a>].</p><p>Interested mentors: Richard Jones, Daniel Frampton</p><h3 id="GoogleSummerofCode2011-TheMMTktestharnesstools">The MMTk test harness tools</h3><p>There are several possible projects here:{</p><ul><li>Implement a weak memory model, and/or tools for checking data races in<br /> the simulated memory.</li><li>Implement a mechanism for running Java applications through the harness.<br /> The most tractable approach might be to use bytecode rewriting to manage<br /> the simulated MMTk heap as a shadow of the Java heap.</li><li>New invariants/checks/tests to detect errors in GC implementations. This could be motivated by a GC implementation project (eg MC^2).</li></ul><p>Interested mentors: Robin Garner, Daniel Frampton</p><h3 id="GoogleSummerofCode2011-SeparateHeapForVMobjects">Separate Heap For VM objects</h3><p>In most JVMs there is no confusion between memory allocated for the application and memory allocated by the running of the VM itself (for example a call to malloc() within the JIT). However, in Jikes RVM, the VM and the application are both written in Java. Moreover, they currently share the same heap. It would be very desirable to improve this situation and separately allocate VM and application objects. Aside from cleaner accounting and behaving more like a production JVM, there may be opportunities for performance optimizations since the lifetimes of objects created by the JIT will typically be bounded by the invocation of a single compilation, as an example.</p><p>This project would start by identifying all transitions from the application into the VM proper and channeling all such transitions through a zero-cost &quot;trap&quot;, which simply serves as a marker. The trap can be viewed as analogous to a kernel trap in the OS setting. The project would also involve writing a simple checking routine which would walk the stack and determine whether execution was currently within the VM or application context. The combination of these mechanisms could then be used to identify and verify all application&lt;-&gt;VM transitions.</p><p>Interested mentors: Andreas Sewe</p><h2 id="GoogleSummerofCode2011-Compilerproposals">Compiler proposals</h2><h3 id="GoogleSummerofCode2011-Multi-coreparallelcompilationservices">Multi-core parallel compilation services</h3><p>This project would add support to Jikes RVM runtime compilation to enable parallel compilation of methods in two different modes. Mode 1 (as at present) - individual methods are compiled sequentially in a single thread. Multiple methods could be compiled in parallel in separate threads. Mode 2 (new feature) - an individual method could be compiled using parallel data flow analysis in multiple threads. This would benefit compilation for large methods. There is an interesting research project in working out the trade-off between these two modes of parallel compilation. The GSoC project would involve generating the infrastructure to carry out this research project.</p><p>Interested mentors: Jeremy Singer</p><h3 id="GoogleSummerofCode2011-Portoftheoptcompilertox86_64">Port of the opt compiler to x86_64</h3><p>The opt compiler is completely ported to ppc64, so this would require a similar piece of work for the x86 code generator. If the baseline compiler is working on x86_64, then the assembler work has already been done, so porting the opt compiler actually should be entirely doable by someone who is comfortable with lowlevel x86/x86_64 debugging.</p><p>Interested mentors: Tony Hosking, Eliot Moss</p><h3 id="GoogleSummerofCode2011-Improvedregisterallocatorforx86andx86_64">Improved register allocator for x86 and x86_64</h3><p>The current linear scan allocator works best with register rich architectures. This project would look at providing a better allocator for architectures that provide fewer registers.</p><p>Interested mentors: Tony Hosking, Eliot Moss</p><h3 id="GoogleSummerofCode2011-GIST">GIST</h3><p>The CoGenT project at UMass aims to make it easier to generate compiler components given descriptions of compiler IRs and of target machines. One of its tools is a generator of instruction selectors; we call it GIST. We have GIST somewhat working to generate the target dependent part of the Jikes RVM Baseline compiler.</p><ul><li>Rounding out automatic generation of the instruction selector (&quot;code generator&quot;) for the<br /> Baseline compiler.</li></ul><ul><li>Developing automatic generation of BURS rules (which are quite similar to the patterns that<br /> GIST finds anyway) for the Jikes RVM Opt compiler.</li></ul><p>{We would first create code generators for existing targets (x86 and PowerPC) to validate the work, and could then proceed to new target (64-bit x86, and look at new platforms, though a complete platform port has somewhat broader scope).</p><ul><li>Generating peephole optimizers using GIST is also a possibility, though at this stage perhaps more challenging.</li></ul><ul><li>Creating a quality &quot;generic&quot; register allocator for the Opt compiler that a GIST-related tool could target would be an excellent project. This could work along the lines of &quot;A Generalized Algorithm for Graph-Coloring Register Allocation&quot; by Smith, Ramsey, and Holloway (PLDI, 2004), possibly with coalescing as well.</li></ul><ul><li>It would also be attractive to follow a similar plan for generating linear-scan register allocators for the Jikes RVM Opt compiler from machine descriptions.</li></ul><ul><li>Finally, GIST, augmented with suitable cost models for each target, could be used to generate<br /> instruction schedulers automatically.</li></ul><p>Any of these projects would advance both Jikes RVM and the CoGenT tools.</p><p>Interested mentors: Eliot Moss and Chip Weems</p><h3 id="GoogleSummerofCode2011-Objectsplitting">Object splitting</h3><p>This project involves a profiling infrastructure to measure field hotness, changes to the JIT compilers to deal with accesses to cold fields, and changes to the garbage collector(s) to allocate cold fields out of the way of hot objects. Given such an infrastructure, future work could then study alternative implementations, or ideas such as the lazy allocation of the cold fields.</p><p>Interested mentor: Matthias Hauswirth</p><h2 id="GoogleSummerofCode2011-RuntimeServices">Runtime Services</h2><h3 id="GoogleSummerofCode2011-ExtendingVMMagic">Extending VM Magic</h3><p>Jikes RVM uses an extended variant on Java, which includes special types and intrinsic methods that are essential to the internals of the VM but that cannot be expressed in regular Java. For example, we implement an <code>Address</code> type, which corresponds roughly to C's <code>void*</code>. This type has a magical size (the size of an architectural word), and magic semantics (for example you can de reference it and even prefetch on it). None of these semantics could be implemented with regular Java.</p><p>An important feature of VM Magic which has not been properly implemented is compound types (roughly equivalent to C's <code>struct</code> types). Such types would be very useful within Jikes RVM because they represent compound types without the overhead and restriction of an object header. This project will implement compound types for Jikes RVM.</p><p>A useful reference is the <a href="http://cs.anu.edu.au/%7ESteve.Blackburn/pubs/abstracts.html#vmmagic-vee-2009" class="external-link" rel="nofollow">2009 paper</a> describing VM Magic, including some of these unimplemented features.</p><p>Interested mentors: Steve Blackburn, Daniel Frampton, Eliot Moss</p><h3 id="GoogleSummerofCode2011-Support(asubsetof)theJVMToolInterface(JVMTI)">Support (a subset of) the JVM Tool Interface (JVMTI)</h3><p>The <a href="http://java.sun.com/j2se/1.5.0/docs/guide/jvmti/jvmti.html" class="external-link" rel="nofollow">JVMTI</a> is large. This project would concentrate on providing support for GC-related JVMTI functionality.</p><p>Suggested by: Suriya Subramanian<br /> Interested mentors: Steve Blackburn, Richard Jones, Daniel Frampton, Eliot Moss</p><h3 id="GoogleSummerofCode2011-Supportforjmap,jhat,jstack">Support for jmap, jhat, jstack</h3><p>This project would provide support for JVM debugging facilities such as <a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jmap.html" class="external-link" rel="nofollow">jmap</a> which dumps an application's heap, <a href="http://java.sun.com/javase/6/docs/technotes/tools/share/jhat.html" class="external-link" rel="nofollow">jhat</a> which examines the dumped heap, and <a href="http://java.sun.com/j2se/1.5.0/docs/tooldocs/share/jstack.html" class="external-link" rel="nofollow">jstack</a> which dumps an application's stack.</p><p>Suggested by: Suriya Subramanian<br /> Interested mentors: Steve Blackburn, Daniel Frampton</p><h3 id="GoogleSummerofCode2011-IntegrationwithMaxineVM&#39;sInspector">Integration with Maxine VM's Inspector</h3><p>The <a href="http://wikis.sun.com/display/MaxineVM/Inspector" class="external-link" rel="nofollow">Maxine Inspector</a> plays many roles:</p><ul><li>object, class, and method browser;</li><li>code views include disassembled machine code, disassembled bytecode, and source;</li><li>low-level debugger (imagine gdb or dbx) with visual displays of threads, registers, stacks, * stack frames, thread local values, breakpoints, memory watchpoints, etc.;</li><li>intermediate representation debugger; etc.</li></ul><p>This project would provide an interface to the Inspector.</p><p>Suggested by: Suriya Subramanian<br /> Interested mentors: Steve Blackburn, Daniel Frampton</p><h3 id="GoogleSummerofCode2011-ProbesforDTrace">Probes for DTrace</h3><p>DTrace allows user-space code to add so-called USDT (User-level Statically Defined Tracing) probes (see example below). It would be useful to be able to use DTrace to correlate system behavior (e.g. scheduling, thread migration, ...) with behavior of the Jikes RVM (e.g. locking, GC, ...).</p><p>Interested mentors: Matthias Hauswirth</p>
                    </div>

                    
                 
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Apr 01, 2015 16:31</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
